<!-- generated by tools/gen-readme -->

# upon

[![Crates.io Version](https://img.shields.io/crates/v/upon.svg)](https://crates.io/crates/upon)
[![Docs.rs Latest](https://img.shields.io/badge/docs.rs-latest-blue.svg)](https://docs.rs/upon)
[![Build Status](https://img.shields.io/github/workflow/status/rossmacarthur/upon/build/trunk)](https://github.com/rossmacarthur/upon/actions?query=workflow%3Abuild)

A lightweight and powerful template engine for Rust.

## Table of Contents

- [Overview](#overview)
  - [Syntax](#syntax)
  - [Engine](#engine)
  - [Why another template engine?](#why-another-template-engine)
  - [MSRV](#msrv)
- [Getting started](#getting-started)
- [Features](#features)
- [Examples](#examples)
  - [Render using structured data](#render-using-structured-data)
  - [Transform data using filters](#transform-data-using-filters)
  - [Render a template using custom syntax](#render-a-template-using-custom-syntax)
  - [Render a template to an `impl io::Write`](#render-a-template-to-an-impl-iowrite)
  - [Add and use a custom formatter](#add-and-use-a-custom-formatter)
- [Benchmarks](#benchmarks)
- [License](#license)

## Overview

### Syntax

- Expressions: `{{ user.name }}`
- Conditionals: `{% if user.enabled %} ... {% endif %}`
- Loops: `{% for user in users %} ... {% endfor %}`
- Nested templates: `{% include "nested" %}`
- Configurable delimiters: `<? user.name ?>`, `(( if user.enabled ))`
- Arbitrary user defined filters: `{{ user.name | replace: "\t", " " }}`

See the `syntax` module for the full syntax documentation.

### Engine

- Clear and well documented API
- Customizable value formatters: `{{ user.name | escape_html }}`
- Render to a `String` or any `std::io::Write` implementor
- Render using any `serde` serializable values
- Convenient macro for quick rendering:
  `upon::value!{ name: "John", age: 42 }`
- Pretty error messages when displayed using `{:#}`
- Minimal dependencies and decent runtime performance

### Why another template engine?

It’s true there are already a lot of template engines for Rust!

I created `upon` because I required a template engine that had runtime
compiled templates, configurable syntax delimiters and minimal dependencies.
I also didn’t need support for arbitrary expressions in the template syntax
but occasionally I needed something more flexible than outputting simple
values. Performance was also a concern for me, template engines like
[Handlebars] and [Tera] have a lot of features but can be up to five to
seven times slower to render than engines like [TinyTemplate].

Basically I wanted something like [TinyTemplate] with support for
configurable delimiters and user defined filter functions. The syntax is
inspired by template engines like [Liquid] and [Jinja].

### MSRV

Currently the minimum supported version for `upon` is Rust 1.60. The MSRV
policy is to support the last **five** minor versions of Rust (~30 weeks).

## Getting started

First, add the crate to your Cargo manifest.

```sh
cargo add upon
```

Now construct an `Engine`. The engine stores the syntax config, filter
functions, formatters, and compiled templates. Generally, you only need to
construct one engine during the lifetime of a program.

```rust
let engine = upon::Engine::new();
```

Next, `.add_template` is used to compile and store a
template in the engine.

```rust
engine.add_template("hello", "Hello {{ user.name }}!")?;
```

Finally, the template is rendered by fetching it using
`.get_template` and calling
`.render`.

```rust
let template = engine.get_template("hello").unwrap();
let result = template.render(upon::value!{ user: { name: "John Smith" }})?;
assert_eq!(result, "Hello John Smith!");
```

If the lifetime of the template source is shorter than the engine lifetime
or you don’t need to store the compiled template then you can also use the
`.compile` function to return the template directly.

```rust
let template = engine.compile("Hello {{ user.name }}!")?;
let result = template.render(upon::value!{ user: { name: "John Smith" }})?;
assert_eq!(result, "Hello John Smith!");
```

## Features

- **filters** *(enabled by default)* — Enables support for filters in
  templates, see `Engine::add_filter()`. This does *not* affect value
  formatters, see `Engine::add_formatter()`. Disabling this will improve
  compile times.

- **serde** *(enabled by default)* — Enables all serde support and pulls in
  the `serde` crate as a dependency. If disabled then you can use
  `.render_from()` to render templates and
  construct the context using `Value`’s `From` impls.

- **unicode** *(enabled by default)* — Enables unicode support and pulls in
  the `unicode-ident` and `unicode-width`
  crates. If disabled then unicode identifiers will no longer be allowed in
  templates and `.chars().count()` will be used in error formatting.

## Examples

The following section contains some simple examples. See the
[`examples/`](https://github.com/rossmacarthur/upon/tree/trunk/examples) directory in the repository for more.

### Render using structured data

You can render using any `serde` serializable data.

```rust
#[derive(serde::Serialize)]
struct Context { user: User }

#[derive(serde::Serialize)]
struct User { name: String }

let ctx = Context { user: User { name: "John Smith".into() } };

let result = upon::Engine::new()
    .compile("Hello {{ user.name }}")?
    .render(&ctx)?;

assert_eq!(result, "Hello John Smith");
```

### Transform data using filters

Data can be transformed using registered filters.

```rust
let mut engine = upon::Engine::new();
engine.add_filter("lower", str::to_lowercase);

let result = engine
    .compile("Hello {{ value | lower }}")?
    .render(upon::value! { value: "WORLD!" })?;

assert_eq!(result, "Hello world!");
```

See the `filters` module documentation for more information on filters.

### Render a template using custom syntax

The template syntax can be set by constructing an engine using
`Engine::with_syntax`.

```rust
let syntax = upon::Syntax::builder().expr("<?", "?>").block("<%", "%>").build();

let result = upon::Engine::with_syntax(syntax)
    .compile("Hello <? user.name ?>")?
    .render(upon::value!{ user: { name: "John Smith" }})?;

assert_eq!(result, "Hello John Smith");
```

### Render a template to an `impl io::Write`

You can render a template directly to a buffer implementing `io::Write`
by using `.render_to_writer()`.

```rust
use std::io;

let stdout = io::BufWriter::new(io::stdout());

upon::Engine::new()
    .compile("Hello {{ user.name }}")?
    .render_to_writer(stdout, upon::value! { user: { name: "John Smith" }})?;
```

### Add and use a custom formatter

You can add your own custom formatter’s or even override the default
formatter using `Engine::set_default_formatter`. The following example
shows how you could add `debug` formatter to the engine.

```rust
use std::fmt::Write;
use upon::{Value, Result};

let mut engine = upon::Engine::new();
engine.add_formatter("debug", |f, value| {
    write!(f, "Value::{:?}", value)?;
    Ok(())
});


let result = engine
    .compile("User age: {{ user.age | debug }}")?
    .render(upon::value! { user: { age: 23 } })?;

assert_eq!(result, "User age: Value::Integer(23)");
```

See the `fmt` module documentation for more information.

[Handlebars]: https://crates.io/crates/handlebars
[Tera]: https://crates.io/crates/tera
[TinyTemplate]: https://crates.io/crates/tinytemplate
[TinyTemplate]: https://crates.io/crates/tinytemplate
[Liquid]: https://liquidjs.com
[Jinja]: https://jinja.palletsprojects.com

## Benchmarks

`upon` was benchmarked against several popular template rendering engines in the
Rust ecosystem. Obviously, each of these engines has a completely different
feature set so the benchmark just compares the performance of some of the
features that they share. Handlebars is so slow that it is excluded from the
compile violin plot.

- [handlebars](https://crates.io/crates/handlebars)
- [liquid](https://crates.io/crates/liquid)
- [minijinja](https://crates.io/crates/minijinja)
- [tera](https://crates.io/crates/tera)
- [tinytemplate](https://crates.io/crates/tinytemplate)

![Violin plot of compile results](./benches/results/compile.svg)
![Violin plot of render results](./benches/results/render.svg)

Benchmarking was done using [criterion](https://crates.io/crates/criterion) on
a quiet cloud machine.

**Host**

- Vultr.com
- 4 CPU
- 8192 MB RAM
- Ubuntu 20.04
- Rust 1.64.0

## License

Licensed under either of

- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or
  http://www.apache.org/licenses/LICENSE-2.0)
- MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.
