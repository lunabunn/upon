use std::env;
use std::fs;
use std::iter;
use std::path::PathBuf;
use std::process;

use std::fmt::{Display, Write as _};
use std::io;

use either::Either;
use itertools::Itertools;

const WORKSPACE_DIR: &str = env!("CARGO_WORKSPACE_DIR");

fn main() -> io::Result<()> {
    let path = PathBuf::from_iter([WORKSPACE_DIR, "src", "filters", "impls.rs"]);
    let tmp = path.with_extension("tmp");

    let prev = fs::read_to_string(&path).unwrap_or_else(|_| String::new());
    let curr = gen();
    fs::write(&tmp, curr)?;

    let status = process::Command::new("rustfmt").arg(&tmp).status()?;
    if !status.success() {
        println!("rustfmt failed :/");
        return Ok(());
    }

    let curr = fs::read_to_string(&tmp)?;

    if prev != curr {
        fs::rename(&tmp, &path)?;
        println!("{} was updated!", path.display());
    } else {
        fs::remove_file(&tmp)?;
        println!("{} is up to date", path.display());
    }

    Ok(())
}

fn gen() -> String {
    let mut out = String::from(
        r#"
//! Code generated by *./tools/gen-filters*. DO NOT EDIT.

#![allow(clippy::needless_lifetimes)]

use std::collections::BTreeMap;

use crate::filters::args::{ListRef, MapRef, Str, ValueRef};
use crate::filters::{Filter, FilterArg, FilterArgs, FilterReturn};
use crate::Value;

    "#,
    );

    let value_types = [
        ArgType::Owned,
        ArgType::Str,
        ArgType::ListRef,
        ArgType::MapRef,
        ArgType::ValueRef,
    ]
    .as_slice();
    let arg_types = [ArgType::Owned, ArgType::Str].as_slice();
    let all = [value_types, arg_types, arg_types, arg_types, arg_types];
    let generics: Vec<_> = iter::once('V').chain('A'..='U').take(all.len()).collect();

    for types in (1..=all.len()).flat_map(|i| all[..i].iter().copied().multi_cartesian_product()) {
        if types.iter().all(|t| matches!(t, ArgType::Owned)) {
            continue;
        }

        let args: Vec<_> = types
            .into_iter()
            .enumerate()
            .map(|(i, t)| match t {
                ArgType::Owned => Arg::Generic(generics[i]),
                ArgType::Str => Arg::Borrowed {
                    impl_type: "Str",
                    fn_type: "&str",
                    fn_type_lt: "&'a str",
                },
                ArgType::ListRef => Arg::Borrowed {
                    impl_type: "ListRef",
                    fn_type: "&[Value]",
                    fn_type_lt: "&'a [Value]",
                },
                ArgType::MapRef => Arg::Borrowed {
                    impl_type: "MapRef",
                    fn_type: "&BTreeMap<String, Value>",
                    fn_type_lt: "&'a BTreeMap<String, Value>",
                },
                ArgType::ValueRef => Arg::Borrowed {
                    impl_type: "ValueRef",
                    fn_type: "&Value",
                    fn_type_lt: "&'a Value",
                },
            })
            .collect();

        out.push_str(&render(&args));
    }
    out
}

#[derive(Debug, Clone, Copy)]
enum ArgType {
    Owned,
    Str,
    ListRef,
    MapRef,
    ValueRef,
}

enum Arg {
    Generic(char),
    Borrowed {
        impl_type: &'static str,
        fn_type: &'static str,
        fn_type_lt: &'static str,
    },
}

fn render(args: &[Arg]) -> String {
    // Generics
    let generics = join(args.iter().filter_map(Arg::maybe_generic));

    // Types that we are implementing the Filter on
    let impl_tuple = join(args.iter().map(Arg::impl_type));

    // Arguments to the closure
    let fn_args = join(args.iter().map(Arg::fn_type));

    // Arguments to the closure
    let fn_args_lt = join(args.iter().map(Arg::fn_type_lt));

    // Where clauses for the generics
    let wheres = join(args.iter().filter_map(Arg::maybe_where));

    // Comma separate variables for the function impl
    let vars = join(iter::once('v').chain('a'..='u').take(args.len()));

    format!(
        "
#[doc(hidden)]
impl<Func, R, {generics}> Filter<R, ({impl_tuple})> for Func
where
    Func: Fn({fn_args}) -> R,
    R: FilterReturn,
{wheres}

    ({impl_tuple}): for<'a> FilterArgs<'a, Output = ({fn_args_lt})>,
{{
    fn filter<'a>(&self, ({vars}): ({fn_args_lt})) -> R {{
        self({vars})
    }}
}}
",
    )
}

impl Arg {
    fn maybe_generic(&self) -> Option<char> {
        match self {
            Self::Generic(c) => Some(*c),
            Self::Borrowed { .. } => None,
        }
    }

    fn maybe_where(&self) -> Option<String> {
        match self {
            Arg::Generic(c) => Some(format!("\n    {c}: for<'a> FilterArg<'a, Output = {c}>")),
            Arg::Borrowed { .. } => None,
        }
    }

    fn impl_type(&self) -> impl Display + '_ {
        match self {
            Self::Generic(c) => Either::Left(c),
            Self::Borrowed { impl_type, .. } => Either::Right(impl_type),
        }
    }

    fn fn_type(&self) -> impl Display + '_ {
        match self {
            Self::Generic(c) => Either::Left(c),
            Self::Borrowed { fn_type, .. } => Either::Right(fn_type),
        }
    }

    fn fn_type_lt(&self) -> impl Display + '_ {
        match self {
            Self::Generic(c) => Either::Left(c),
            Self::Borrowed { fn_type_lt, .. } => Either::Right(fn_type_lt),
        }
    }
}

fn join<I, D>(iter: I) -> String
where
    I: Iterator<Item = D>,
    D: Display,
{
    let mut s = String::new();
    for item in iter {
        write!(s, "{},", item).unwrap();
    }
    s
}
